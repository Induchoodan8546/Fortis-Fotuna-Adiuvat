<!DOCTYPE html>
<html>

<head>
    <title>Milky Way Simulation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            width: 100%;
            height: 100vh;
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat.gui/0.7.7/dat.gui.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/OrbitControls/2.0.0/OrbitControls.min.js"></script>
</head>

<body>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Camera position
        camera.position.set(0, 50, 100);
        camera.lookAt(0, 0, 0);

        // OrbitControls for navigation
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.enableRotate = true;

        // Central Bulge (bright core)
        const bulgeGeometry = new THREE.SphereGeometry(10, 32, 32);
        const bulgeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff99, transparent: true, opacity: 0.8 });
        const bulge = new THREE.Mesh(bulgeGeometry, bulgeMaterial);
        scene.add(bulge);

        // Stars (spiral arms with particles)
        const particles = 20000; // Adjustable for performance
        const starGeometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particles * 3);
        const colors = new Float32Array(particles * 3);

        for (let i = 0; i < particles; i++) {
            const i3 = i * 3;
            const radius = Math.random() * 80 + 20; // Inner radius + spiral extent
            const angle = Math.random() * Math.PI * 2;
            const arm = Math.floor(Math.random() * 4); // 4 spiral arms
            const offset = (arm * Math.PI * 2) / 4 + (Math.random() - 0.5) * 0.5; // Spiral offset

            positions[i3] = radius * Math.cos(angle + offset); // X
            positions[i3 + 1] = (Math.random() - 0.5) * 10; // Y (disk thickness)
            positions[i3 + 2] = radius * Math.sin(angle + offset); // Z

            // Colors: yellowish center, bluish arms
            const color = new THREE.Color().setHSL(0.1 + Math.random() * 0.1, 0.8, 0.5 + (1 - radius / 100) * 0.5);
            colors[i3] = color.r;
            colors[i3 + 1] = color.g;
            colors[i3 + 2] = color.b;
        }

        starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        const starMaterial = new THREE.PointsMaterial({ size: 0.5, vertexColors: true, transparent: true, opacity: 0.8 });
        const stars = new THREE.Points(starGeometry, starMaterial);
        scene.add(stars);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040); // Soft ambient
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(0, 0, 0); // Centered at bulge
        scene.add(pointLight);

        // Animation
        function animate() {
            requestAnimationFrame(animate);
            stars.rotation.y += 0.001; // Slow rotation for galaxy effect
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>

</html>